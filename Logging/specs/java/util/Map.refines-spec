// Copyright (C) 2002 Iowa State University

// This file is part of JML

// JML is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.

// JML is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with GNU Emacs; see the file COPYING.  If not, write to
// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

package java.util;

/** JML's specification of java.util.Map.
 * @version $Revision: 2120 $
 * @author Katie Becker
 * @author Gary T. Leavens
 * @author David R. Cok
 * @author Viliam Holub
 */
public interface Map {
    //@ public non_null model instance JMLDataGroup mapObjectState;
    //@ public non_null model instance JMLDataGroup localState; in mapObjectState;

    /*@ public normal_behavior
      @   ensures \result == ( o == oo ||
      @        ( o != null && oo != null && o.equals(oo)));
      @ static public model pure boolean nullequals(Object o, Object oo);
      @*/

    /**
     * Explicit type of keys and element in the Map. These are set by the user.
     * Specification then guarantee type retrieved from the collection and
     * refines type-cast exceptions warnings.
     */
    //@ instance public ghost \TYPE keyType = \type(Object); in localState;
    //@ instance public ghost \TYPE elementType = \type(Object); in localState;

    /**
     * Whether null elements are allowed in the map. Set by the user.
     */
    //@ instance ghost public boolean containsNull = false; in localState;

    /**
     * Whether null keys are allowed. Set by the user.
     */
     //@ instance ghost public boolean nullKeys = false; in localState;

    /**
     * Whether the put operation is supported. Set by the user.
     */
    //@ instance ghost public boolean putSupported = true; in localState;

    /**
     * Whether the putAll operation is supported. Set by the user.
     */
    //@ instance ghost public boolean putAllSupported = true; in localState;

    /**
     * Whether the remove operation is supported. Set by the user.
     */
    //@ instance ghost public boolean removeSupported = true; in localState;

    //-@ immutable
    /*-@ pure public static model class Content {

          public \bigint theSize;

          // This is object containment (not equals)
          public normal_behavior
            ensures true;
          //-@ function pure
          public Object mapsObject(Object key);


          public normal_behavior
            ensures true;
          //-@ function pure
          public Object maps(Object key);

          public normal_behavior
            ensures true;
          public function pure boolean hasMapObject(Object key);

          public normal_behavior
            ensures true;
          //-@ function pure
          public boolean hasMap(Object key);
        }
      @*/

    /*-@
        public invariant (\forall Object o; content.theSize == 0 ==> 
                      !content.hasMapObject(o));
        public invariant (\forall Object o; content.theSize == 0 ==>
                      !content.hasMap(o));
        public invariant content.theSize == 0 ==> !content.hasMapObject(null);
        public invariant content.theSize == 0 ==> !content.hasMap(null);
      @*/
    /*-@ axiom (\forall Content c; (\forall Object o;
                   c.hasMapObject(o) ==> c.hasMap(o)));
        axiom (\forall Content c; c.hasMapObject(null) <==> c.hasMap(null));
        axiom (\forall Content c; (\forall Object o;
                   c.hasMapObject(o) ==> c.mapsObject(o) == c.maps(o)));
        axiom (\forall Content c;
                   c.hasMapObject(null) ==> c.mapsObject(null) == c.maps(null));
     */
          
    //-@ public model instance non_null Content content; in localState;
    //-@ public invariant content.owner == this;

    /*-@ public normal_behavior
      @   ensures \result <==> ( 
             content != null &&
             content.theSize == 0  && 
             (\forall Object o; !content.hasMapObject(o)) &&
             (\forall Object o; !content.hasMap(o)) &&
             !content.hasMapObject(null) &&
             !content.hasMap(null) 
             );
      @*/
    /*@ model pure public boolean initialMap();
      @*/

    public static interface Entry {

        //@ public model instance Object abstractKey;
        //@ public model instance Object abstractValue;
		
        /*@  public normal_behavior
          @     ensures \result == abstractKey;
          @*/
        /*@ pure @*/ Object getKey();

        /*@  public normal_behavior
          @     ensures \result == abstractValue;
          @*/
        /*@ pure @*/ Object getValue();
		
        /*@ public behavior
          @     assignable this.abstractValue;
          @     ensures \result == \old(this.abstractValue);
          @     ensures this.abstractValue == value;
          @
          @   // FIXME - fix these exceptions
          @     signals_only NullPointerException, UnsupportedOperationException,
                               ClassCastException, IllegalArgumentException;
          @     signals (NullPointerException) \not_modified(this.abstractValue);
          @     signals (UnsupportedOperationException)
          @               \not_modified(this.abstractValue) 
          @             && (* if the map's put operation is not supported  *);
          @     signals (ClassCastException) \not_modified(this.abstractValue)
          @             && (* \typeof(abstractValue) is incompatible
          @                with the valueType of this map *);
          @     signals (IllegalArgumentException) \not_modified(this.abstractValue)
          @             && (* if some aspect of value is not 
          @                allowed in the map *);
          @*/
        Object setValue(Object value);

        /*@  also
          @   public normal_behavior
          @     requires o instanceof Entry;
          @     ensures \result ==  ( this == o ||
          @      (    nullequals(((Entry)o).abstractKey, abstractKey)
          @        && nullequals(((Entry)o).abstractValue, abstractValue) ));
          @  also
          @   public normal_behavior
          @     requires !(o instanceof Entry);
          @     ensures \result == false;
          @*/
        /*@ pure @*/ boolean equals(/*@ nullable @*/ Object o);

        /*@ pure @*/ int hashCode();

        /*@ public normal_behavior
          @   ensures \result <==> (nullequals(abstractKey,key) &&
          @                         nullequals(abstractValue, value));
          @ public pure model boolean equals(Object key, Object value);
          @
          @
          @ public normal_behavior
          @   ensures \result <==> (abstractKey == key &&
          @                         abstractValue == value);
          @ public pure model boolean equalsObjects(Object key, Object value);
          @
          @
          @ public normal_behavior
          @   ensures \result <==> equalsObjects(e.getKey(),e.getValue());
          @ public pure model boolean equalsObjects(Entry e);
          @*/
    }

    //@ public normal_behavior
    //@   ensures (* \result == content.theSize *);
    //-@   ensures \result == content.theSize;
    /*@ pure @*/
    int size();

    /*-@ public normal_behavior
      @    ensures \result <==> (content.theSize == 0); 
      @*/
    /*@ pure @*/ boolean isEmpty();
	
    /*-@ public normal_behavior
      @    ensures isEmpty() ==> !\result;
      @    ensures content.hasMap(key) <==> \result;
      @ also
      @ public exceptional_behavior
      @    signals_only ClassCastException, NullPointerException;
      @    signals (ClassCastException) !(\typeof(key) <: keyType);
      @    // if this map doesn't support null keys
      @    signals (NullPointerException) key == null && !nullKeys;
      @*/
    /*@ pure @*/ boolean containsKey(Object key) throws RuntimeException;

    /*-@ public behavior
      @    ensures isEmpty() ==> !\result;
      @    ensures \result <==> (
              nullequals(value,content.mapsObject(null)) ||
              (\exists Object k; nullequals(value,content.mapsObject(k))));
      @
      @    signals_only ClassCastException, NullPointerException;
      @    signals (ClassCastException) !(\typeof(value) <: elementType);
      @    signals (NullPointerException) value == null && !containsNull;
      @*/
    /*@ pure @*/ boolean containsValue(Object value);

    /*-@ public normal_behavior
      @    requires !content.hasMap(key);// hasMap or hasMapObject -- FIXME
      @    ensures \result == null;
      @ also public normal_behavior
      @    requires content.hasMap(key);    // hasMap or hasMapObject -- FIXME
      @    ensures \result == content.maps(key);
      @ also public normal_behavior
      @    requires content.hasMapObject(key);
      @    ensures \result == content.mapsObject(key);
      @
      @    ensures !containsNull ==> \result != null;
      @    ensures \typeof(\result) <: elementType;
      @
      @ also public exceptional_behavior
      @
      @    signals_only ClassCastException, NullPointerException;
      @    signals (ClassCastException) !(\typeof(key) <: keyType);
      @    signals (NullPointerException) key == null && !nullKeys;
      @*/
    /*@ pure @*/ Object get(Object key);

    /*-@ public normal_behavior
      @    assignable mapObjectState;
      @    ensures content.hasMap(key);
      @    ensures !isEmpty() && containsKey(key) && containsValue(value);
      @    ensures content.mapsObject(key) == value;
      @    ensures content.maps(key) == value;
      @    ensures \result == \old(get(key));

      @    ensures (\forall Object k; k != key ==> 
                        (\old(content.hasMapObject(k)) 
                                       == content.hasMapObject(k)));
      @    ensures key != null ==> (\old(content.hasMapObject(null)) 
                                       == content.hasMapObject(null));

      @
      @    ensures (\forall Object k; k.equals(key) ==> content.hasMap(k));
      @    ensures (\forall Object k; \old(!k.equals(key)) ==> 
                        (\old(content.hasMap(k)) == content.hasMap(k)));
      @    ensures key != null ==> (\old(content.hasMap(null)) 
                                       == content.hasMap(null));
      @
      @    ensures (\forall Object k; k.equals(key) ==> content.maps(k) == value);
      @    ensures (\forall Object k; \old(!k.equals(key)) ==> 
                        \old(content.maps(k)) == content.maps(k));
      @    ensures key != null ==> 
                        \old(content.maps(null)) == content.maps(null);
      @
      @    ensures (\forall Object k; \old(!k.equals(key)) ==> 
                        \old(content.mapsObject(k)) == content.mapsObject(k));
      @    ensures key != null ==> \old(content.mapsObject(null)) 
                                       == content.mapsObject(null);
      @ also
      @ public exceptional_behavior
      @    assignable \nothing;
      @    signals_only NullPointerException, UnsupportedOperationException, ClassCastException, IllegalArgumentException;
      @    // if the put operation is not supported by this map
      @    signals (UnsupportedOperationException) \not_modified(value)
      @             && !putSupported;
      @    // if this map does not permit null keys or values, and the specified key or value is null
      @    signals (NullPointerException) \not_modified(value)
      @             && ((key==null && !nullKeys) || (value==null && !containsNull));
      @    // if the type the specified key or value is incompatible with the specified types
      @    signals (ClassCastException) \not_modified(value)
      @             && (!(\typeof(key) <: keyType) || !(\typeof(value) <: elementType));
      @    // if some aspect of the value or key is not allowed in this map
      @    signals (IllegalArgumentException)
      @             (* if some aspect of key or value is not 
      @                allowed in the map *);
      @*/
    Object put(Object key, Object value);

    /*-@ public behavior
      @    assignable mapObjectState;
      @    ensures !content.hasMapObject(key);
      @    ensures !content.hasMap(key);
      @    ensures !containsKey(key);
      @    ensures (\forall Object k; \old(!k.equals(key)) ==> 
                        \old(content.mapsObject(k)) == content.mapsObject(k));
      @    ensures key != null ==> 
                        \old(content.mapsObject(null)) == content.mapsObject(null);
      @    ensures \result == \old(get(key));
      @
      @    signals_only ClassCastException, NullPointerException,
                               UnsupportedOperationException;
      @    // If the remove operation is not supported
      @    signals (UnsupportedOperationException) !removeSupported;
      @    // If the key has unsupported type
      @    signals (ClassCastException) !(\typeof(key) <: keyType);
      @    // If this map doesn't support null keys
      @    signals (NullPointerException) key == null && !nullKeys;
      @*/
    Object remove(Object key);

    /*@ public behavior
           requires t != null;
           assignable mapObjectState;
           ensures \old(isEmpty() && t.isEmpty()) <==> isEmpty();
           ensures (\forall Object k; \old(t.containsKey(k) || containsKey(k)) 
                                       <==> containsKey(k));
           ensures (\forall Object k; \old(t.containsKey(k)) ==>  
                                              t.get(k) == get(k));
           ensures (\forall Object k; \old(containsKey(k) && !t.containsKey(k))
                                              ==> get(k) == \old(get(k)));
        also public exceptional_behavior
           requires t == null;
           assignable \nothing;
           signals_only NullPointerException, UnsupportedOperationException, ClassCastException, IllegalArgumentException;
      @
      @    // if the specified map is null or there are null values or keys
      @    // and this map does not allow them
      @    signals (NullPointerException)
      @             (t == null
      @             || (!nullKeys && t.nullKeys && t.containsKey(null))
      @             || (!containsNull && t.containsNull &&
      @             	(\exists Object k; t.containsKey(k) && get(k)==null))
      @             );
      @    // if the map's put operation is not supported
      @    signals (UnsupportedOperationException) 
      @             !putAllSupported;
      @    signals (ClassCastException)
      @             (* \typeof(t) or is incompatible
      @                with this map *);
      @    signals (IllegalArgumentException)
      @             (* if some aspect of a key or value is not 
      @                allowed in the map *);
      @*/
    void putAll(Map t);

    /*-@ public normal_behavior
      @    assignable mapObjectState;
      @    ensures isEmpty();
      @    ensures (\forall Object k; !content.hasMapObject(k));
      @*/
    void clear();

    /*@ public normal_behavior 
      @    ensures \result != null;
           // FIXME
      @*/
    /*@ pure @*/ Set keySet();

    /*@ public normal_behavior 
      @    ensures \result != null;
           // FIXME
      @*/
    /*@ pure @*/ Collection values();

    /*@ public normal_behavior
      @    ensures \result != null; 
           // FIXME
      @*/
    /*@ pure @*/ Set entrySet();

    /*@
      @ also
      @  public normal_behavior
      @    requires (o instanceof Map);
      @    ensures \result == this.entrySet().equals( ((Map)o).entrySet() );
      @ also public normal_behavior
      @    requires !(o instanceof Map);
      @    ensures !\result;
      @*/
    /*@ pure @*/ boolean equals(/*@ nullable @*/ Object o);
	
    /*@ pure @*/ int hashCode();
}
